from pathlib import Path

import cardiac_geometries
import ldrb
import simcardems
import pulse

msh_file = "geometries/patient.msh"
geo = cardiac_geometries.gmsh2dolfin(msh_file)

ldrb_markers = {
    "base": geo.markers["BASE"][0],
    "lv": geo.markers["ENDO"][0],
    "epi": geo.markers["EPI"][0],
}

fiber_space = "DG_1"

# Create a dictionary of fiber angles

angles = dict(
    alpha_endo_lv=60,  # Fiber angle on the endocardium
    alpha_epi_lv=-60,  # Fiber angle on the epicardium
    beta_endo_lv=0,  # Sheet angle on the endocardium
    beta_epi_lv=0,
)


f0, s0, n0 = ldrb.dolfin_ldrb(
    mesh=geo.mesh,
    fiber_space=fiber_space,
    ffun=geo.marker_functions.ffun,
    markers=ldrb_markers,
    **angles
)
f0.set_allow_extrapolation(True)
s0.set_allow_extrapolation(True)
n0.set_allow_extrapolation(True)

here = Path(__file__).absolute().parent
outdir = here / "results_patient_specific_lv"
outdir.mkdir(exist_ok=True)

# # dolfin.File((outdir / "ffun.pvd").as_posix()) << geo.marker_functions.ffun
# # dolfin.File((outdir / "f0.pvd").as_posix()) << f0
# print(geo.markers)
# exit()


geometry = simcardems.lvgeometry.LeftVentricularGeometry(
    mechanics_mesh=geo.mesh,
    microstructure=pulse.Microstructure(f0=f0, s0=s0, n0=n0),
    ffun=geo.marker_functions.ffun,
    markers=geo.markers,
    parameters={"num_refinements": 1, "fiber_space": fiber_space},
)


# Specify path to the initial conditions for the cell model
initial_conditions_path = (
    here / "initial_conditions/fully_coupled_Tor_Land/init_5000beats.json"
)

config = simcardems.Config(
    outdir=outdir,
    coupling_type="fully_coupled_Tor_Land",
    T=1000,
    spring=0.01,  # Sprint term on the epicardium to mimic pericardium
    traction=0.0,  # Pressure on the endocardium
    cell_init_file=initial_conditions_path,
)

# And create the coupling. Note that, here we are using a different method than usual for creating the coupling, since we need to also supply the geometry.

coupling = simcardems.models.em_model.setup_EM_model_from_config(
    config=config,
    geometry=geometry,
)

# Next we create the runner, and solve the problem

runner = simcardems.Runner.from_models(config=config, coupling=coupling)

# # First inflate ventricle
pulse.iterate.iterate(
    problem=runner.coupling.mech_solver,
    control=runner.coupling.mech_solver.bcs.neumann[0].traction,
    target=1.0,  # Set it to 1kPa
)


runner.solve(T=config.T, save_freq=config.save_freq, show_progress_bar=False)

# Now let us only extract the results of the membrane potential, and compare the values in different points in the mesh. For the slab geometry we can for example evaluate the functions a the minimum and maximum $x$ values and at the center. To do this, we need to first load the results

# loader = simcardems.DataLoader(outdir / "results.h5")


# simcardems.postprocess.plot_state_traces(outdir.joinpath("results.h5"))

#
# Here the traces generated by averaging over this domain.


# This will create a figure in the output directory called `state_traces.png` which in this case is shown in {numref}`Figure {number} <lv_demo_state_traces>` we see the resulting state traces, and can also see the instant drop in the active tension ($T_a$) at the time of the triggered release.
#
# ```{figure} figures/lv_demo_state_traces.png
# ---
# name: lv_demo_state_traces
# ---
# Traces of the stretch ($\lambda$), the active tension ($T_a$), the membrane potential ($V$) and the intercellular calcium concentration ($Ca$) at the center of the geometry.
# ```

#
# We can also save the output to xdmf-files that can be viewed in Paraview
#

simcardems.postprocess.make_xdmffiles(outdir.joinpath("results.h5"), names=["u"])
